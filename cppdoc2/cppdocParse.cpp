#include "stdinc.h"
extern string slash;

/*@****************************************************************************
@DATA	vector<cdClass>		classList	"List of classes"
@DATA	vector<cdFunction>	funcList	"List of functions"
@DATA	vector<cdGlobal>	globals		"List of global variables"
@DATA	string				projName	"Project name"
@DATA	string				version		"Current project version"
@DATA	string				copyYear	"Copyright year"
@DATA	string				copyright	"Copyright owner"
@DATA	string				projDesc	"Project description"
****************************************************************************@*/
vector<cdClass> classList;		// List of classes
vector<cdFunction> funcList;	// List of functions
vector<cdGlobal> globals;		// List of global variables
string projName;				// Project name
string version;					// Project version
string copyYear;				// Copyright year
string copyright;				// Copyright owner
string projDesc;				// Project description

/*@****************************************************************************
@FUNCTION	cppdocParse			VOID
@CREATED	"Parallel Minds"	"11/10/2002"

@PARAM		vector<string>&	filelist	"List of input files"
@PARAM		string&			outputdir	"User-specified output directory"
@PARAM		char			flags		"Flags generated by command-line switches"
@RETURNS	VOID

@DESC	"Primary parsing front-end.  Sends each file to doParse() function
		 to be fully parsed, then creates the output directory and sends
		 the parsed data to the writeDoc function.  Finally, it creates the
		 index.html file."
****************************************************************************@*/
void cppdocParse(vector<string>& filelist, string& outputdir, char flags)
{
	unsigned int i = 0;				// Iterator
	unsigned int j = 0;				// Iterator

	// Tell the user what's going on
	cout << "Parsing input files...\n";

	// Parse each file in the list
	for(i = 0; i < filelist.size(); i++)
	{
		// Tell the user what's going on
		cout << "\tParsing " << filelist[i] << "..." << endl;

		// Open the input file
		ifstream inFile(filelist[i].c_str());

		if(!inFile)
			cout << "File " << filelist[i] << " not found.  File skipped." << endl;
		else
			// Parse the input file
			doParse(inFile, flags);

		// Close the input file
		inFile.close();
	}
	// Tell the user what's going on
	cout << "Parsing complete.  Creating output directory.\n";

	// Attempt to create the output directory
	string cmd = "mkdir " + outputdir;
	int syserr = system(cmd.c_str());

	// If error 1 was returned, the directory already exists.
	// Tell the user and continue.
	if(syserr == 1)
		cout << "Overwriting existing files...\n";
	else
		cout << "Generating cppdoc files...\n";

	// Write the cppdoc HTML files based on the class list
	// and the function list
	writeDoc(outputdir, flags);

	// Create the index file
	string html_head = "<html><head>\n  <title>";
	if(projName == "")
		html_head += "cppdoc";
	else
		html_head = html_head + projName + ", version " + version + " (cppdoc)";
	html_head += "</title>\n  ";
	if((flags & 0x02) == 0)
		html_head += "<link rel=\"stylesheet\" href=\"cppdoc.css\" type=\"text/css\">\n";
	html_head += "</head>\n";
	string html_foot = "</body>\n</html>";

	// Make a default CSS document if one does not already exist,
	// CSS has not been disabled, and the user did not specify
	// a CSS document to use
	string cssdocname = outputdir + slash + "cppdoc.css";
	ifstream cssdoccheck(cssdocname.c_str());
	if((flags & 0x02) == 0 && (flags & 0x04) == 0 && !cssdoccheck)
	{
		cout << "Creating default CSS document." << endl;
		cssdoccheck.close();
		ofstream cssdoc(cssdocname.c_str());

		cssdoc << "body               { font-family: arial;" << endl;
		cssdoc << "                     background-color: black;" << endl;
		cssdoc << "                     color: white; }" << endl;
		cssdoc << "body.lframe        { background-color: white;" << endl;
		cssdoc << "                     color: black; }" << endl;
		cssdoc << "body.tframe        { background-color: #800000;" << endl;
		cssdoc << "                     color: white; }" << endl;
		cssdoc << endl;
		cssdoc << "a.parent:link      { color: white; }" << endl;
		cssdoc << "a.parent:visited   { color: white; }" << endl;
		cssdoc << "a.parent:hover     { color: red;" << endl;
		cssdoc << "                     text-decoration: none; }" << endl;
		cssdoc << "a.parent:link      { color: white; }" << endl;
		cssdoc << "a.parent:visited   { color: white; }" << endl;
		cssdoc << "a.parent:hover     { color: red;" << endl;
		cssdoc << "                     text-decoration: none; }" << endl;
		cssdoc << "a.children:link    { color: white; }" << endl;
		cssdoc << "a.children:visited { color: white; }" << endl;
		cssdoc << "a.children:hover   { color: red;" << endl;
		cssdoc << "                     text-decoration: none; }" << endl;
		cssdoc << "a.clf_link:link    { color: black; }" << endl;
		cssdoc << "a.clf_link:visited { color: black; }" << endl;
		cssdoc << "a.clf_link:hover   { color: black;" << endl;
		cssdoc << "                     text-decoration: none;" << endl;
		cssdoc << "                     color: red; }" << endl;
		cssdoc << endl;
		cssdoc << "table.mFuncTable   { width: 60%;" << endl;
		cssdoc << "                     background-color: white;" << endl;
		cssdoc << "                     color: black; }" << endl;
		cssdoc << "table.mDataTable   { width: 60%;" << endl;
		cssdoc << "                     background-color: white;" << endl;
		cssdoc << "                     color: black; }" << endl;
		cssdoc << "table.globalVars   { width: 60%;" << endl;
		cssdoc << "                     background-color: white;" << endl;
		cssdoc << "                     color: black; }" << endl;
		cssdoc << endl;
		cssdoc << "td.mFuncHeader     { background-color: #800000;" << endl;
		cssdoc << "                     color: white;" << endl;
		cssdoc << "                     font-weight: bold;" << endl;
		cssdoc << "                     padding: 5px;" << endl;
		cssdoc << "                     border-left: 1px solid black;" << endl;
		cssdoc << "                     border-right: 1px solid black;" << endl;
		cssdoc << "                     border-top: 1px solid black; }" << endl;
		cssdoc << "td.mFuncDesc       { border-left: 1px solid black;" << endl;
		cssdoc << "                     border-right: 1px solid black;" << endl;
		cssdoc << "                     border-bottom: 1px solid black;" << endl;
		cssdoc << "                     padding-left: 30px; }" << endl;
		cssdoc << "td.mFuncSpacer     { background-color: black; }" << endl;
		cssdoc << "td.mDataHeader     { background-color: #800000;" << endl;
		cssdoc << "                     color: white;" << endl;
		cssdoc << "                     font-weight: bold;" << endl;
		cssdoc << "                     padding: 5px;" << endl;
		cssdoc << "                     border-left: 1px solid black;" << endl;
		cssdoc << "                     border-right: 1px solid black;" << endl;
		cssdoc << "                     border-top: 1px solid black; }" << endl;
		cssdoc << "td.mDDesc          { border-left: 1px solid black;" << endl;
		cssdoc << "                     border-right: 1px solid black;" << endl;
		cssdoc << "                     border-bottom: 1px solid black;" << endl;
		cssdoc << "                     padding-left: 30px; }" << endl;
		cssdoc << "td.globalHeader    { background-color: #800000;" << endl;
		cssdoc << "                     color: white;" << endl;
		cssdoc << "                     font-weight: bold;" << endl;
		cssdoc << "                     padding: 5px;" << endl;
		cssdoc << "                     border-left: 1px solid black;" << endl;
		cssdoc << "                     border-right: 1px solid black;" << endl;
		cssdoc << "                     border-top: 1px solid black; }" << endl;
		cssdoc << "td.gvDesc          { border-left: 1px solid black;" << endl;
		cssdoc << "                     border-right: 1px solid black;" << endl;
		cssdoc << "                     border-bottom: 1px solid black;" << endl;
		cssdoc << "                     padding-left: 30px; }" << endl;
		cssdoc << endl;
		cssdoc << "p.projDesc         { text-align: justify;" << endl;
		cssdoc << "                     width: 60%; }" << endl;
		cssdoc << endl;
		cssdoc << "h1.projName        { margin-bottom: 0px; }" << endl;
		cssdoc << "h1.projNameMain    { margin-bottom: 0px;" << endl;
		cssdoc << "                     font-size: 48pt;" << endl;
		cssdoc << "                     text-align: center; }" << endl;
		cssdoc << "h3.paramHeader     { margin-bottom: 0px; }" << endl;
		cssdoc << "h3.retHeader       { margin-bottom: 0px; }" << endl;
		cssdoc << "h3.descHeader      { margin-bottom: 0px; }" << endl;
		cssdoc << "h3.createHeader    { margin-bottom: 0px; }" << endl;
		cssdoc << "h3.modHeader       { margin-bottom: 0px; }" << endl;
		cssdoc << "h3.gfHeader        { margin-bottom: 0px; }" << endl;
		cssdoc << "h3.gvHeader        { margin-bottom: 0px; }" << endl;
		cssdoc << "h3.classHeader     { margin-bottom: 0px; }" << endl;

		cssdoc.close();
	}

	// If frames are disabled
	if((flags & 0x10) != 0)
	{
		// Open the index file and write out the HTML header
		string ofname = outputdir + slash + "index.html";
		ofstream outFile(ofname.c_str());
		outFile << html_head;
		outFile << "<body>\n";

		// Write links to the classes
		for(i = 0; i < classList.size(); i++)
		{
			outFile << "<a class=\"clink\" href=\"C_" << classList[i].name << ".html\">";
			outFile << classList[i].name << "</a><br>\n";
		}
		outFile << "<br>\n";

		bool globalFunction = false;

		// If there are any global functions, print out their
		// prototypes here.  Any function that does not have
		// a parent class is global.
		for(i = 0; i < funcList.size(); i++)
		{
			if(!funcList[i].hasParent)
			{
				if(!globalFunction)
					outFile << "<h3 class=\"gfHeader\">Global Functions</h3>";

				// If this is the first global function in the
				// list, create a table.
				if(!globalFunction)
					outFile << "<table cellspacing=0 class=\"mFuncTable\">\n";

				// Print the function prototype...
				// returntype name(paramtype paramname, etc.)
				outFile << "  <tr>\n    <td class=\"mFuncHeader\">";
				outFile << stripHTML(funcList[i].retType) << " ";
				outFile << funcList[i].name << "(";
				for(j = 0; j < funcList[i].paramName.size(); j++)
				{
					if(j > 0)
						outFile << ", ";
					outFile << stripHTML(funcList[i].paramType[j]) << " ";
					outFile << funcList[i].paramName[j];
				}
				outFile << ")</td>\n  </tr>";

				// Print the function description
				outFile << "  <tr>\n    <td class=\"mFuncDesc\"><h3 class=\"descHeader\">";
				outFile << "Description</h3>";
				outFile << stripHTML(funcList[i].desc) << "</h3>";

				// Print a list of parameters along with descriptions
				for(j = 0; j < funcList[i].paramName.size(); j++)
				{
					if(j == 0)
						outFile << "<h3 class=\"paramHeader\">Parameters</h3>";
					outFile << stripHTML(funcList[i].paramType[j]) << " ";
					outFile << funcList[i].paramName[j] << " - ";
					outFile << stripHTML(funcList[i].paramDesc[j]) << "<br>";
				}

				// Function return information
				outFile << "<h3 class=\"retHeader\">Returns</h3>";
				if(strToUpper(funcList[i].retType) == "VOID")
					outFile << "<i>Nothing</i>";
				else
				{
					outFile << stripHTML(funcList[i].retType) << " - ";
					outFile << funcList[i].retDesc;
				}
				outFile << "<br><br>";

				// Print the creator's name and creation date, if
				// available.
				if(funcList[i].creator != "" || funcList[i].created != "")
				{
					outFile << "Created by " << funcList[i].creator << " (";
					outFile << funcList[i].created << ")<br>";
				}

				// Print out the names of the modifiers and the
				// dates of modification
				for(j = 0; j < funcList[i].modifiers.size(); j++)
				{
					if(j == 0)
						outFile << "Modified:<br>";

					outFile << "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
					outFile << funcList[i].modifiers[j] << " (";
					outFile << funcList[i].modified[j] << ")<br>";
				}

				outFile << "</td>\n  </tr>\n";
				outFile << "  <tr>\n    <td class=\"mFuncSpacer\">&nbsp;</td>\n  </tr>\n";

				// There is at least one global function so the
				// <table> tag will need to be closed
				globalFunction = true;
			}
		}

		// If there are any global functions, close the table
		if(globalFunction)
			outFile << "</table>\n";

		for(i = 0; i < globals.size(); i++)
		{
			if(i == 0)
			{
				outFile << "<table cellspacing=0 class=\"globalVars\">\n";
				outFile << "  <tr>\t    <td class=\"globalHeader\">Global Variables</td>\n  </tr>\n";
				outFile << "  <tr>\n    <td class=\"gvDesc\">";
			}
			outFile << globals[i].type << " " << globals[i].name << " - " << globals[i].desc << "<br>\n";
		}

		// Print the HTML footer
		outFile << html_foot;

		// Close the output file
		outFile.close();
	}
	else
	{
		// Open the index file and write out the HTML header
		string ofname = outputdir + slash + "index.html";
		ofstream outFile(ofname.c_str());
		outFile << html_head;
		outFile << "<frameset rows=\"100,*\" frameborder=0>\n  <frame src=\"tframe.html\" name=\"tframe\">\n";
		outFile << "<frameset cols=\"200,*\" frameborder=0>\n    ";
		outFile << "<frame src=\"lframe.html\" name=\"lframe\">\n    <frame src=\"mainp.html\" name=\"mainp\">\n  ";
		outFile << "</frameset>\n</frameset>\n";
		outFile << html_foot;
		outFile.close();

		ofname = outputdir + slash + "lframe.html";
		outFile.open(ofname.c_str());
		outFile << html_head;
		outFile << "<body class=\"lframe\">\n";

		// Write links to the classes
		for(i = 0; i < classList.size(); i++)
		{
			if(i == 0)
				outFile << "<h3 class=\"classHeader\">Classes</h2>\n";
			outFile << "<a class=\"clf_link\" href=\"C_" << classList[i].name << ".html\" target=\"mainp\">";
			outFile << classList[i].name << "</a><br>\n";
		}

		j = 0;
		for(i = 0; i < funcList.size(); i++)
		{
			if(!funcList[i].hasParent)
			{
				if(j == 0)
				{
					outFile << "<h3 class=\"gfHeader\">Global Functions</h3>\n";
					j++;
				}
				else
					outFile << "<br>";
				outFile << "<a class=\"clf_link\" href=\"mainp.html#f_" << funcList[i].name << "\" target=\"mainp\">";
				outFile << funcList[i].name << "</a>\n";
			}
		}
		if(j > 0)
			outFile << "<br>";

		for(i = 0; i < globals.size(); i++)
		{
			if(i == 0)
				outFile << "<h3 class=\"gvHeader\">Global Variables</h3>\n";
			outFile << "<a class=\"clf_link\" href=\"mainp.html#v_" << globals[i].name << "\" target=\"mainp\">";
			outFile << globals[i].name << "</a><br>\n";
		}

		outFile << "<br>\n";
		outFile << "<a class=\"clf_link\" href=\"mainp.html\" target=\"mainp\">Front Page</a>\n";
		outFile << "</body>";
		outFile << html_foot;
		outFile.close();

		ofname = outputdir + slash + "tframe.html";
		outFile.open(ofname.c_str());
		outFile << html_head;
		outFile << "<body class=\"tframe\">\n";
		outFile << "<h1 class=\"projName\">" << projName << "</h1>\nVersion " << version;
		if(copyright != "")
			outFile << ", &copy; Copyright " << copyYear << ", " << copyright << "\n</body>";
		outFile << html_foot;
		outFile.close();

		ofname = outputdir + slash + "mainp.html";
		outFile.open(ofname.c_str());
		outFile << html_head;
		outFile << "<body class=\"mainp\">\n";
		outFile << "<h1 class=\"projNameMain\">" << projName << "</h1>\n";
		outFile << "<center>Version " << version;
		if(copyright != "")
			outFile << ", &copy; Copyright " << copyYear << ", " << copyright << "<br><br>\n";
		outFile << "<p class=\"projDesc\">" << projDesc << "</p>\n";

		bool globalFunction = false;

		// If there are any global functions, print out their
		// prototypes here.  Any function that does not have
		// a parent class is global.
		for(i = 0; i < funcList.size(); i++)
		{
			if(!funcList[i].hasParent)
			{
				if(!globalFunction)
					outFile << "<h3 class=\"gfHeader\">Global Functions</h3>";

				// If this is the first global function in the
				// list, create a table.
				if(!globalFunction)
					outFile << "<table cellspacing=0 class=\"mFuncTable\">\n";

				// Print the function prototype...
				// returntype name(paramtype paramname, etc.)
				outFile << "  <tr>\n    <td class=\"mFuncHeader\">";
				outFile << "<a name=\"f_" << funcList[i].name << "\">";
				outFile << stripHTML(funcList[i].retType) << " ";
				outFile << funcList[i].name << "(";
				for(j = 0; j < funcList[i].paramName.size(); j++)
				{
					if(j > 0)
						outFile << ", ";
					outFile << stripHTML(funcList[i].paramType[j]) << " ";
					outFile << funcList[i].paramName[j];
				}
				outFile << ")</a></td>\n  </tr>";

				// Print the function description
				outFile << "  <tr>\n    <td class=\"mFuncDesc\"><h3 class=\"descHeader\">";
				outFile << "Description</h3>";
				outFile << stripHTML(funcList[i].desc) << "</h3>";

				// Print a list of parameters along with descriptions
				for(j = 0; j < funcList[i].paramName.size(); j++)
				{
					if(j == 0)
						outFile << "<h3 class=\"paramHeader\">Parameters</h3>";
					outFile << stripHTML(funcList[i].paramType[j]) << " ";
					outFile << funcList[i].paramName[j] << " - ";
					outFile << stripHTML(funcList[i].paramDesc[j]) << "<br>";
				}

				// Function return information
				outFile << "<h3 class=\"retHeader\">Returns</h3>";
				if(strToUpper(funcList[i].retType) == "VOID")
					outFile << "<i>Nothing</i>";
				else
				{
					outFile << stripHTML(funcList[i].retType) << " - ";
					outFile << funcList[i].retDesc;
				}
				outFile << "<br><br>";

				// Print the creator's name and creation date, if
				// available.
				if(funcList[i].creator != "" || funcList[i].created != "")
				{
					outFile << "Created by " << funcList[i].creator << " (";
					outFile << funcList[i].created << ")<br>";
				}

				// Print out the names of the modifiers and the
				// dates of modification
				for(j = 0; j < funcList[i].modifiers.size(); j++)
				{
					if(j == 0)
						outFile << "Modified:<br>";

					outFile << "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
					outFile << funcList[i].modifiers[j] << " (";
					outFile << funcList[i].modified[j] << ")<br>";
				}

				outFile << "</td>\n  </tr>\n";
				outFile << "  <tr>\n    <td class=\"mFuncSpacer\">&nbsp;</td>\n  </tr>\n";

				// There is at least one global function so the
				// <table> tag will need to be closed
				globalFunction = true;
			}
		}

		for(i = 0; i < globals.size(); i++)
		{
			if(i == 0)
			{
				outFile << "<table cellspacing=0 class=\"globalVars\">\n";
				outFile << "  <tr>\t    <td class=\"globalHeader\">Global Variables</td>\n  </tr>\n";
				outFile << "  <tr>\n    <td class=\"gvDesc\">";
			}
			outFile << "<a name=\"v_" << globals[i].name << "\">";
			outFile << globals[i].type << " " << globals[i].name << " - " << globals[i].desc << "</a><br>\n";
		}

		outFile << "</body>";
		outFile << html_foot;
		outFile.close();
	}
}

/*@****************************************************************************
@FUNCTION	writeDoc			VOID
@CREATED	"Parallel Minds"	"11/10/2002"

@PARAM		string&		outputdir	"User-specified output directory"
@PARAM		char		flags		"Flags generated by command-line switches"
@RETURNS	VOID

@DESC	"Writes an HTML file for each cppdoc class object and links related
		 classes together."
****************************************************************************@*/
void writeDoc(string& outputdir, char flags)
{
	unsigned int i = 0;		// Iterator

	// HTML header and footer information
	string html_head = "<html><head>\n  <title>cppdoc</title>\n  ";
	if((flags & 0x02) == 0)
		html_head += "<link rel=\"stylesheet\" href=\"cppdoc.css\" type=\"text/css\">\n";
	html_head += "</head>\n<body>\n";
	string html_foot = "</body>\n</html>";

	// For each class, loop once...
	for(i = 0; i < classList.size(); i++)
	{
		// This is probably an outdated IF, dating to a
		// first-implementation that had classes and
		// functions stored in one big vector
		if(classList[i].docObjectType == "CLASS")
		{
			unsigned int j = 0;		// Iterator

			// Open the output file
			string ofname = outputdir + slash + "C_" + classList[i].name + ".html";
			cout << "\t\tWriting file " << ofname << endl;
			ofstream outFile(ofname.c_str());

			// Write the HTML header
			outFile << html_head;

			// Class name
			outFile << "Class <i>" << classList[i].name << "</i>";
			if(classList[i].hasParent)
			{
				// Class has a parent.  If parent is known, make
				// a link; otherwise just display the name
				bool knownParent = false;
				outFile << "<br>Derived from ";
				for(j = 0; j < classList.size(); j++)
					if(classList[j].name == classList[i].parent)
					{
						outFile << "<a class=\"parent\" href=\"C_" << classList[i].parent << ".html\">";
						knownParent = true;
					}

				// Parent class's name
				outFile << "<i>" << classList[i].parent << "</i>";
				if(knownParent)
					outFile << "</a>";
			}
			// Description
			outFile << "<br><br>" << endl;
			if(classList[i].desc != "")
				outFile << stripHTML(classList[i].desc) << "<br><br>\n";

			// Creator name/date
			if(classList[i].creator != "")
			{
				outFile << "Created by ";
				outFile << classList[i].creator << " (" << classList[i].created << ")<br>\n";
			}

			// List of modification dates and modifiers
			if(classList[i].modified.size() > 0)
				outFile << "Modifications:<br>\n";
			for(j = 0; j < classList[i].modified.size(); j++)
			{
				outFile << "  " << classList[i].modifiers[j] << " (";
				outFile << classList[i].modified[j] << ")<br>\n";
			}
			if(classList[i].creator != "" || classList[i].modified.size() > 0)
				outFile << "<br>\n";

			// List member functions
			for(j = 0; j < classList[i].mFName.size(); j++)
			{
				// If this is the first member function, open
				// the HTML table
				if(j == 0)
					outFile << "<table class=\"mFuncTable\" cellspacing=0>" << endl;

				// Write the function access type, return type, and
				// name (of the function prototype)
				outFile << "  <tr>\n    <td class=\"mFuncHeader\">";
				outFile << classList[i].mFAccess[j] << " ";
				outFile << stripHTML(classList[i].mFType[j]) << " ";
				outFile << classList[i].mFName[j] << "(";

				unsigned int k = 0;	// Iterator
				int findex = -1;	// Function index number

				// Find the index of the member function in the
				// function list
				for(k = 0; k < funcList.size(); k++)
					if(funcList[k].name == classList[i].mFName[j] &&
					   funcList[k].parent == classList[i].name)
						findex = k;

				// If the index >= 0, then it was found so print
				// the information from the function list rather
				// than from the class list
				if(findex >= 0)
				{
					// Print the function parameter types and names
					for(k = 0; k < funcList[findex].paramType.size(); k++)
					{
						if(k > 0)
							outFile << ", ";
						outFile << stripHTML(funcList[findex].paramType[k]) << " ";
						outFile << funcList[findex].paramName[k];
					}
				}

				// End of member function prototype
				outFile << ")</td>\n  </tr>\n";

				// If there is cppdoc code for the member function...
				if(findex >= 0)
				{
					// Print the function description from the function list
					outFile << "  <tr>\n    <td class=\"mFuncDesc\">";
					outFile << "<h3 class=\"descHeader\">Description</h3>";
					outFile << stripHTML(funcList[findex].desc);

					// Print a list of member function parameters
					outFile << "<h3 class=\"paramHeader\">Parameters</h3>";
					for(k = 0; k < funcList[findex].paramType.size(); k++)
					{
						outFile << stripHTML(funcList[findex].paramType[k]) << " ";
						outFile << funcList[findex].paramName[k] << " - ";
						outFile << stripHTML(funcList[findex].paramDesc[k]) << "<br>";
					}

					// Print the member function return information
					outFile << "<h3 class=\"retHeader\">Returns</h3>";
					if(strToUpper(funcList[findex].retType) == "VOID")
						outFile << "<i>Nothing</i>";
					else
					{
						outFile << stripHTML(funcList[findex].retType) << " - ";
						outFile << stripHTML(funcList[findex].retDesc);
					}

					outFile << "</td>\n";
					outFile << "  </tr>\n" << endl;
				}
				// The only information about the member funciton is in the
				// parent class's cppdoc comments
				else
				{
					outFile << "  <tr>\n    <td class=\"mFuncDesc\">";
					outFile << stripHTML(classList[i].mFDesc[j]);
					outFile << "</td>\n  </tr>\n";
				}

				outFile << "  <tr>\n    <td class=\"mFuncSpacer\">&nbsp;</td>\n  </tr>\n";

			}

			// Close the table if it was opened, otherwise just a line break
			if(classList[i].mFName.size() > 0)
				outFile << "</table>" << endl;
			if(classList[i].mDName.size() <= 0)
				outFile << "<br>\n";

			// List member data
			for(j = 0; j < classList[i].mDName.size(); j++)
			{
				// If this is the first member data, open the table
				// and print the member data headers
				if(j == 0)
				{
					outFile << "<table cellspacing=0 class=\"mDataTable\">\n";
					outFile << "  <tr>\n    <td class=\"mDataHeader\">";
					outFile << "<h3 class=\"mDHeader\">Member Data</h3></td>\n";
					outFile << "  </tr>\n";
					outFile << "  <tr>\n    <td class=\"mDDesc\">";
				}

				// Print the member data access type, data type,
				// name, and description
				outFile << classList[i].mDAccess[j] << " ";
				outFile << stripHTML(classList[i].mDType[j]) << " ";
				outFile << classList[i].mDName[j] << " - ";
				outFile << stripHTML(classList[i].mDDesc[j]) << "<br>";
			}
			//Close the table if it was opened
			if(classList[i].mDName.size() > 0)
				outFile << "</td>\n  </tr>\n</table><br>" << endl;

			// List any classes derived from this one
			string derivedClasses = "";
			bool hasChildren = false;
			for(j = 0; j < classList.size(); j++)
				if(classList[j].parent == classList[i].name)
				{
					derivedClasses += "<a class=\"children\" href=\"C_" + classList[j].name + ".html\">";
					derivedClasses += classList[j].name + "</a>, ";
					hasChildren = true;
				}

			if(hasChildren)
				outFile << "Children classes: " << derivedClasses.substr(0, derivedClasses.size() - 2);

			// Write the HTML footer and close the file
			outFile << html_foot;
			outFile.close();
		}
	}
}

/*@****************************************************************************
@FUNCTION	doParse				VOID
@CREATED	"Parallel Minds"	"11/10/2002"

@PARAM		ifstream&	inFile	"Input file"
@PARAM		char		flags	"Flags generated by command-line switches"
@RETURNS	VOID

@DESC		"Parses the input file for cppdoc-style comments and stores that
			 information in the classList and funcList vectors.  This function
			 is not responsible for any output."
****************************************************************************@*/
void doParse(ifstream& inFile, char flags)
{
	// A string for keeping up with the current cppdoc directive and
	// a boolean for tracking whether or not a cppdoc block is open
	string directive;
	bool cppdocBlock = false;

	if(!inFile)
		return;

	// Loop through the whole input file
	while(!inFile.eof())
	{
		// Input a string from the input file
		inFile >> directive;

		// If the directive is the cppdoc opening tag,
		// a cppdoc block is open (duh!)
		if(directive.substr(0,3) == "/*@")
		{
			cdFunction tfunc;
			cdClass tclass;
			cdGlobal tglobal;
	
			// A cppdoc block is open
			cppdocBlock = true;

			// Loop unless the end of the file is reached or
			// the cppdoc block closes
			while(!inFile.eof() && cppdocBlock)
			{
				// Input a string from the input file
				inFile >> directive;

				// If the string begins with an @, it
				// may be a cppdoc directive
				if(directive.substr(0,1) == "@")
				{
					// Convert the directive to uppercase.  This
					// way, cppdoc comments are case-insensitive.
					directive = strToUpper(directive);

					// @PROJECT directive
					if(directive == "@PROJECT" && projName == "")
					{
						string tmp;

						// Input the next string from the file, which
						// is the start of the description
						inFile >> tmp;
						projName = tmp;

						// Keep inputting strings for the description
						// until the last character of one string is
						// a double-quote
						while(tmp.substr(tmp.size() - 1, 1) != "\"")
						{
							inFile >> tmp;
							projName = projName + " " + tmp;
						}

						// If the description is more than two characters,
						// strip the opening and closing quotes.
						if(projName.size() > 2)
							projName = projName.substr(1, projName.size() - 2);
						// Otherwise just blank the description because
						// the two characters are the quotes.
						else
							projName = "";

						inFile >> version;
					}

					// @COPY directive
					else if(directive == "@COPY")
					{
						inFile >> copyYear;

						string tmp;

						// Input the next string from the file, which
						// is the start of the description
						inFile >> tmp;
						copyright = tmp;

						// Keep inputting strings for the description
						// until the last character of one string is
						// a double-quote
						while(tmp.substr(tmp.size() - 1, 1) != "\"")
						{
							inFile >> tmp;
							copyright = copyright + " " + tmp;
						}

						// If the description is more than two characters,
						// strip the opening and closing quotes.
						if(copyright.size() > 2)
							copyright = copyright.substr(1, copyright.size() - 2);
						// Otherwise just blank the description because
						// the two characters are the quotes.
						else
							copyright = "";
					}

					// @CLASS diretive
					else if(directive == "@CLASS")
					{
						// Read the class name and the parent
						// class name from the input file
						inFile >> tclass.name;
						inFile >> tclass.parent;
						if(strToUpper(tclass.parent) != "VOID")
							tclass.hasParent = true;
						else
							tclass.hasParent = false;
					}

					// @FUNCTION directive
					else if(directive == "@FUNCTION")
					{
						// Read the function name and the name
						// of the class in which it exists from
						// the input file
						inFile >> tfunc.name;
						inFile >> tfunc.parent;
						if(strToUpper(tfunc.parent) != "VOID")
							tfunc.hasParent = true;
						else
							tfunc.hasParent = false;
					}

					// @MFUNCTION directive
					else if(directive == "@MFUNCTION")
					{
						// Temporary variables
						string type;
						string access;
						string name;
						string desc;
						string tmp;

						// Input the member function's return type,
						// access, and name.
						inFile >> type;
						inFile >> access;
						inFile >> name;

						// Input the next string from the file, which
						// is the start of the description
						inFile >> tmp;
						desc = tmp;

						// Keep inputting strings for the description
						// until the last character of one string is
						// a double-quote
						while(tmp.substr(tmp.size() - 1, 1) != "\"")
						{
							inFile >> tmp;
							desc = desc + " " + tmp;
						}

						// If the description is more than two characters,
						// strip the opening and closing quotes.
						if(desc.size() > 2)
							desc = desc.substr(1, desc.size() - 2);
						// Otherwise just blank the description because
						// the two characters are the quotes.
						else
							desc = "";

						// Push the function's return type, access,
						// name, and description into the appropriate
						// vectors
						tclass.mFType.push_back(type);
						tclass.mFAccess.push_back(access);
						tclass.mFName.push_back(name);
						tclass.mFDesc.push_back(desc);
					}

					// @MDATA directive
					else if(directive == "@MDATA")
					{
						// Temporary variables
						string type;
						string access;
						string name;
						string desc;
						string tmp;

						// Input the member data's type, access, and name.
						inFile >> type;
						inFile >> access;
						inFile >> name;

						// Input the next string from the file, which
						// is the start of the description
						inFile >> tmp;
						desc = tmp;

						// Keep inputting strings for the description
						// until the last character of one string is
						// a double-quote
						while(tmp.substr(tmp.size() - 1, 1) != "\"")
						{
							inFile >> tmp;
							desc = desc + " " + tmp;
						}

						// If the description is more than two characters,
						// strip the opening and closing quotes.
						if(desc.size() > 2)
							desc = desc.substr(1, desc.size() - 2);
						// Otherwise just blank the description because
						// the two characters are the quotes.
						else
							desc = "";

						// Push the data's type, access, name, and
						// description into the appropriate vectors
						tclass.mDType.push_back(type);
						tclass.mDAccess.push_back(access);
						tclass.mDName.push_back(name);
						tclass.mDDesc.push_back(desc);
					}

					// @CREATED directive
					else if(directive == "@CREATED")
					{
						// Temporary string
						string tmp;

						// Read in a string, which is the start of
						// the name of the creator
						inFile >> tmp;
						tclass.creator = tmp;

						// Keep inputting strings for the creator name
						// until the last character of one string is
						// a double-quote
						while(tmp.substr(tmp.size() - 1, 1) != "\"")
						{
							inFile >> tmp;
							tclass.creator = tclass.creator + " " + tmp;
						}

						// If the creator name is more than two characters,
						// strip the opening and closing quotes.
						if(tclass.creator.size() > 2)
							tclass.creator = tclass.creator.substr(1, tclass.creator.size() - 2);
						// Otherwise just blank the creator name because
						// the two characters are the quotes.
						else
							tclass.creator = "";
						tfunc.creator = tclass.creator;

						// Read in a string, which is the start of
						// the creation date
						inFile >> tmp;
						tclass.created = tmp;

						// Keep inputting strings for the creator name
						// until the last character of one string is
						// a double-quote
						while(tmp.substr(tmp.size() - 1, 1) != "\"")
						{
							inFile >> tmp;
							tclass.created = tclass.created + " " + tmp;
						}

						// If the creation date is more than two characters,
						// strip the opening and closing quotes.
						if(tclass.created.size() > 2)
							tclass.created = tclass.created.substr(1, tclass.created.size() - 2);
						// Otherwise just blank the creation date because
						// the two characters are the quotes.
						else
							tclass.created = "";
						tfunc.created = tclass.created;
					}

					// @MODIFIED directive
					else if(directive == "@MODIFIED")
					{
						// Temporary strings
						string mName;
						string mDate;
						string tmp;

						// Read in a string, which is the start of
						// the name of the modifier
						inFile >> tmp;
						mName = tmp;

						// Keep inputting strings for the modifier name
						// until the last character of one string is
						// a double-quote
						while(tmp.substr(tmp.size() - 1, 1) != "\"")
						{
							inFile >> tmp;
							mName = mName + " " + tmp;
						}
						// If the modifier name is more than two characters,
						// strip the opening and closing quotes.
						if(mName.size() > 2)
						// Otherwise just blank the modifier name because
						// the two characters are the quotes.
							mName = mName.substr(1, mName.size() - 2);
						else
							mName = "";
						
						// Read in a string, which is the start of
						// the modification date
						inFile >> tmp;
						mDate = tmp;

						// Keep inputting strings for the modification date
						// until the last character of one string is
						// a double-quote
						while(tmp.substr(tmp.size() - 1, 1) != "\"")
						{
							inFile >> tmp;
							mDate = mDate + " " + tmp;
						}
						// If the modification date is more than two
						// characters, strip the opening and closing quotes.
						if(mDate.size() > 2)
							mDate = mDate.substr(1, mDate.size() - 2);
						// Otherwise just blank the modification date because
						// the two characters are the quotes.
						else
							mDate = "";

						// Push the modifier's name and modification
						// date on to the class and function vectors
						tclass.modifiers.push_back(mName);
						tclass.modified.push_back(mDate);
						tfunc.modifiers.push_back(mName);
						tfunc.modified.push_back(mDate);
					}

					// @PARAM directive
					else if(directive == "@PARAM")
					{
						// Temporary variables
						string type;
						string name;
						string desc;
						string tmp;

						// Input the parameter's data type and name
						inFile >> type;
						inFile >> name;

						// Input the next string from the file, which
						// is the start of the description
						inFile >> tmp;
						desc = tmp;

						// Keep inputting strings for the description
						// until the last character of one string is
						// a double-quote
						while(tmp.substr(tmp.size() - 1, 1) != "\"")
						{
							inFile >> tmp;
							desc = desc + " " + tmp;
						}
						// If the description is more than two characters,
						// strip the opening and closing quotes.
						if(desc.size() > 2)
							desc = desc.substr(1, desc.size() - 2);
						// Otherwise just blank the description because
						// the two characters are the quotes.
						else
							desc = "";

						// Push the parameter name, type, and description
						// on to the function parameter vectors
						tfunc.paramName.push_back(name);
						tfunc.paramType.push_back(type);
						tfunc.paramDesc.push_back(desc);
					}

					// @RETURNS directive
					else if(directive == "@RETURNS")
					{
						// Temporary string
						string tmp;

						// Read in the function return type
						inFile >> tfunc.retType;

						// If the return type is not void, then
						// also read in the description
						if(strToUpper(tfunc.retType) != "VOID")
						{
							// Input the next string from the file, which
							// is the start of the return description
							inFile >> tmp;
							tfunc.retDesc = tmp;

							// Keep inputting strings for the description
							// until the last character of one string is
							// a double-quote
							while(tmp.substr(tmp.size() - 1, 1) != "\"")
							{
								inFile >> tmp;
								tfunc.retDesc = tfunc.retDesc + " " + tmp;
							}
							// If the description is more than two characters,
							// strip the opening and closing quotes.
							if(tfunc.retDesc.size() > 2)
								tfunc.retDesc = tfunc.retDesc.substr(1, tfunc.retDesc.size() - 2);
							// Otherwise just blank the description because
							// the two characters are the quotes.
							else
								tfunc.retDesc = "";
						}
					}

					// @DESC directive
					else if(directive == "@DESC")
					{
						// Temporary string
						string tmp;

						// Input the next string from the file, which
						// is the start of the return description
						inFile >> tmp;
						tclass.desc = tmp;

						// The last two characters of the description
						// string.  This is so double-quotes can appear
						// in the description as long as they are escaped
						// with a backslash.
						string lstTwo = tmp.substr(tmp.size() - 2, 2);

						// Loop until an unescaped doublequote appears at the
						// end of a string.
						while(lstTwo == "\\\"" || lstTwo.substr(1,1) != "\"")
						{
							// Input the next string from the file,
							// which is a continuation of the
							// description
							inFile >> tmp;

							// If the string size is greater than
							// one character, find the new lstTwo string
							if(tmp.size() > 1)
								lstTwo = tmp.substr(tmp.size() - 2, 2);
							else
								lstTwo = "  ";

							// If the temp string starts with an escaped
							// double quote, remove the backslash but leave
							// the double quotes
							if(tmp.substr(0,2) == "\\\"")
								tmp = tmp.substr(1, tmp.size() - 1);

							// If the lstTwo string is an escaped double
							// quote, add a double quote to the end of
							// the temp string
							if(lstTwo == "\\\"")
								tmp = tmp.substr(0, tmp.size() - 2) + "\"";

							// Add the temp string to the class
							// description
							tclass.desc = tclass.desc + " " + tmp;
						}

						// If the description is more than two characters,
						// strip the opening and closing quotes.
						if(tclass.desc.size() > 2)
							tclass.desc = tclass.desc.substr(1, tclass.desc.size() - 2);
						// Otherwise just blank the description because
						// the two characters are the quotes.
						else
							tclass.desc = "";

						// Set the function description to the same as the
						// class description
						tfunc.desc = tclass.desc;
						tglobal.desc = tclass.desc;
					}
					else if(directive == "@DATA")
					{
						string tmp;

						inFile >> tglobal.type;
						inFile >> tglobal.name;

						// Input the next string from the file, which
						// is the start of the description
						inFile >> tmp;
						tglobal.desc = tmp;

						// Keep inputting strings for the description
						// until the last character of one string is
						// a double-quote
						while(tmp.substr(tmp.size() - 1, 1) != "\"")
						{
							inFile >> tmp;
							tglobal.desc = tglobal.desc + " " + tmp;
						}
						// If the description is more than two characters,
						// strip the opening and closing quotes.
						if(tglobal.desc.size() > 2)
							tglobal.desc = tglobal.desc.substr(1, tglobal.desc.size() - 2);
						// Otherwise just blank the description because
						// the two characters are the quotes.
						else
							tglobal.desc = "";

						globals.push_back(tglobal);
					}
				}

				// If the directive is more than 2 characters in size,
				// then check to see if is the end cppdoc-block sequence
				if(directive.size() > 2)
				{
					if(directive.substr(directive.size() - 3, 3) == "@*/")
						cppdocBlock = false;

				}//if(directive.size() > 2)
			}//while

			if(tclass.name != "" || tfunc.name != "")
			{
				// If this object is a class, push the class information
				// into the classList vector
				if(tclass.name != "")
					classList.push_back(tclass);
				// Otherwise push the function information into the
				// funcList vector
				else
					funcList.push_back(tfunc);
			}
			else if(projName != "" && tclass.desc != "")
				projDesc = tclass.desc;
		}//if
	}//while
}